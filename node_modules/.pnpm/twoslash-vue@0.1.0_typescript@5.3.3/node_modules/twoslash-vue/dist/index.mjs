import { sharedTypes, SourceMap, createVueLanguage } from '@vue/language-core';
import ts from 'typescript';
import { createTwoslasher as createTwoslasher$1, defaultCompilerOptions, defaultHandbookOptions, createPositionConverter, findQueryMarkers, findFlagNotations, removeCodeRanges, resolveNodePositions, getObjectHash } from 'twoslash';

function createTwoslasher(createOptions = {}) {
  const twoslasherBase = createTwoslasher$1(createOptions);
  const cache = twoslasherBase.getCacheMap();
  const tsOptionDeclarations = ts.optionDeclarations;
  function getVueLanguage(compilerOptions, vueCompilerOptions) {
    if (!cache)
      return createVueLanguage(ts, defaultCompilerOptions, vueCompilerOptions);
    const key = `vue:${getObjectHash([compilerOptions, vueCompilerOptions])}`;
    if (!cache.has(key)) {
      const env = createVueLanguage(ts, defaultCompilerOptions, vueCompilerOptions);
      cache.set(key, env);
      return env;
    }
    return cache.get(key);
  }
  function twoslasher(code, extension, options = {}) {
    if (extension !== "vue")
      return twoslasherBase(code, extension, options);
    const vueCompilerOptions = {
      ...createOptions.vueCompilerOptions,
      ...options.vueCompilerOptions
    };
    const compilerOptions = {
      ...defaultCompilerOptions,
      ...options.compilerOptions
    };
    const handbookOptions = {
      ...defaultHandbookOptions,
      noErrorsCutted: true,
      ...options.handbookOptions
    };
    const sourceMeta = {
      removals: [],
      positionCompletions: [],
      positionQueries: [],
      positionHighlights: [],
      flagNotations: []
    };
    const {
      customTags = createOptions.customTags || []
    } = options;
    const pc = createPositionConverter(code);
    findQueryMarkers(code, sourceMeta, pc);
    const flagNotations = findFlagNotations(code, customTags, tsOptionDeclarations);
    for (const flag of flagNotations) {
      switch (flag.type) {
        case "unknown":
          continue;
        case "compilerOptions":
          compilerOptions[flag.name] = flag.value;
          break;
        case "handbookOptions":
          handbookOptions[flag.name] = flag.value;
          break;
      }
      sourceMeta.removals.push([flag.start, flag.end]);
    }
    let strippedCode = code;
    for (const [start, end] of sourceMeta.removals) {
      strippedCode = strippedCode.slice(0, start) + strippedCode.slice(start, end).replace(/\S/g, " ") + strippedCode.slice(end);
    }
    const lang = getVueLanguage(compilerOptions, vueCompilerOptions);
    const fileSource = lang.createVirtualFile("index.vue", ts.ScriptSnapshot.fromString(strippedCode), "vue");
    const fileCompiled = fileSource.getEmbeddedFiles()[0];
    const typeHelpers = sharedTypes.getTypesCode(fileSource.vueCompilerOptions);
    const compiled = [
      fileCompiled.content.map((c) => Array.isArray(c) ? c[0] : c).join(""),
      "// ---cut-after---",
      typeHelpers
    ].join("\n");
    const map = new SourceMap(fileCompiled.mappings);
    function getLastGeneratedOffset(pos) {
      const offsets = [...map.toGeneratedOffsets(pos)];
      if (!offsets.length)
        return void 0;
      return offsets[offsets.length - 1]?.[0];
    }
    const result = twoslasherBase(compiled, "tsx", {
      ...options,
      compilerOptions: {
        jsx: 4,
        jsxImportSource: "vue",
        noImplicitAny: false,
        ...compilerOptions
      },
      handbookOptions: {
        ...handbookOptions,
        keepNotations: true
      },
      shouldGetHoverInfo(id) {
        return !id.startsWith("__VLS");
      },
      positionCompletions: sourceMeta.positionCompletions.map((p) => getLastGeneratedOffset(p)),
      positionQueries: sourceMeta.positionQueries.map((p) => map.toGeneratedOffset(p)[0]),
      positionHighlights: sourceMeta.positionHighlights.map(([start, end]) => [map.toGeneratedOffset(start)[0], map.toGeneratedOffset(end)[0]])
    });
    if (createOptions.debugShowGeneratedCode)
      return result;
    const mappedNodes = result.nodes.map((q) => {
      if ("text" in q && q.text === "any")
        return void 0;
      const startMap = map.toSourceOffset(q.start);
      if (!startMap)
        return void 0;
      const start = startMap[0];
      let end = map.toSourceOffset(q.start + q.length)?.[0];
      if (end == null && startMap[1].sourceRange[0] === startMap[0])
        end = startMap[1].sourceRange[1];
      if (end == null || start < 0 || end < 0 || start > end)
        return void 0;
      return Object.assign(q, {
        ...q,
        target: code.slice(start, end),
        start: startMap[0],
        length: end - start
      });
    }).filter(isNotNull);
    const mappedRemovals = [
      ...sourceMeta.removals,
      ...result.meta.removals.map((r) => {
        const start = map.toSourceOffset(r[0])?.[0];
        const end = map.toSourceOffset(r[1])?.[0];
        if (start == null || end == null || start < 0 || end < 0 || start >= end)
          return void 0;
        return [start, end];
      }).filter(isNotNull)
    ];
    if (!options.handbookOptions?.keepNotations) {
      const removed = removeCodeRanges(code, mappedRemovals, mappedNodes);
      result.code = removed.code;
      result.meta.removals = removed.removals;
      result.nodes = resolveNodePositions(removed.nodes, result.code);
    } else {
      result.meta.removals = mappedRemovals;
    }
    result.nodes = result.nodes.filter((n, idx) => {
      const next = result.nodes[idx + 1];
      if (!next)
        return true;
      if (next.type === n.type && next.start === n.start)
        return false;
      return true;
    });
    result.meta.extension = "vue";
    return result;
  }
  twoslasher.getCacheMap = twoslasherBase.getCacheMap;
  return twoslasher;
}
const createTwoslasherVue = createTwoslasher;
function isNotNull(x) {
  return x != null;
}

export { createTwoslasher, createTwoslasherVue };

import { VirtualTypeScriptEnvironment } from '@typescript/vfs';
import * as typescript from 'typescript';
import { CompletionEntry, CompilerOptions, CustomTransformers } from 'typescript';

/** Available inline flags which are not compiler flags */
interface HandbookOptions {
    /**
     *  An array of TS error codes, which you write as space separated - this is so the tool can know about unexpected errors
     */
    errors: number[];
    /**
     * Suppress errors for diagnostics and display
     *
     * Setting true to suppress all errors, or an array of error codes to suppress
     */
    noErrors: boolean | number[];
    /**
     * Declare that you don't need to validate that errors have corresponding annotations, defaults to false
     */
    noErrorValidation: boolean;
    /**
     * Whether to disable the pre-cache of LSP calls for interesting identifiers, defaults to false
     */
    noStaticSemanticInfo: boolean;
    /**
     * Shows the JS equivalent of the TypeScript code instead
     */
    showEmit: boolean;
    /**
     * Must be used with showEmit, lets you choose the file to present instead of the source - defaults to index.js which
     * means when you just use `showEmit` above it shows the transpiled JS.
     */
    showEmittedFile?: string;
    /**
     * Do not remove twoslash notations from output code, the nodes will have the position of the input code.
     * @default false
     */
    keepNotations: boolean;
    /**
     * Do not check errors in the cutted code.
     * @default false
     */
    noErrorsCutted: boolean;
}

/**
 * Basic node with start and length to represent a range in the code
 */
interface NodeStartLength {
    /** 0-indexed position of the node in the file */
    start: number;
    /** The length of the node */
    length: number;
}
interface NodeBase extends NodeStartLength, Position {
}
interface NodeHover extends NodeBase {
    type: 'hover';
    /** The string content of the node this represents (mainly for debugging) */
    target: string;
    /** The base LSP response (the type) */
    text: string;
    /** Attached JSDoc info */
    docs?: string;
    /** JSDoc tags */
    tags?: [name: string, text: string | undefined][];
}
interface NodeHighlight extends NodeBase {
    type: 'highlight';
    /** The annotation message */
    text?: string;
}
interface NodeQuery extends Omit<NodeHover, 'type'> {
    type: 'query';
}
interface NodeCompletion extends NodeBase {
    type: 'completion';
    /** Results for completions at a particular point */
    completions: CompletionEntry[];
    completionsPrefix: string;
}
interface NodeError extends NodeBase {
    type: 'error';
    id: string;
    level: 0 | 1 | 2 | 3;
    code: number;
    text: string;
    filename: string;
}
interface NodeTag extends NodeBase {
    type: 'tag';
    /** What was the name of the tag */
    name: string;
    /** What was the text after the `// @tag: ` string  (optional because you could do // @tag on it's own line without the ':') */
    text?: string;
}
type TwoslashNode = NodeHighlight | NodeHover | NodeQuery | NodeCompletion | NodeError | NodeTag;
type NodeWithoutPosition = Omit<NodeHighlight, keyof Position> | Omit<NodeHover, keyof Position> | Omit<NodeQuery, keyof Position> | Omit<NodeCompletion, keyof Position> | Omit<NodeError, keyof Position> | Omit<NodeTag, keyof Position>;
type NodeErrorWithoutPosition = Omit<NodeError, keyof Position>;
interface Position {
    /**
     * 0-indexed line number
     */
    line: number;
    /**
     * 0-indexed column number
     */
    character: number;
}
type Range = [start: number, end: number];

interface TwoslashReturn {
    /** The output code, could be TypeScript, but could also be a JS/JSON/d.ts */
    code: string;
    /**
     * Nodes containing various bits of information about the code
     */
    nodes: TwoslashNode[];
    /**
     * The meta information the twoslash run
     */
    meta: TwoslashReturnMeta;
    get queries(): NodeQuery[];
    get completions(): NodeCompletion[];
    get errors(): NodeError[];
    get highlights(): NodeHighlight[];
    get hovers(): NodeHover[];
    get tags(): NodeTag[];
}
interface TwoslashReturnMeta {
    /**
     * The new extension type for the code, potentially changed if they've requested emitted results
     */
    extension: string;
    /**
     * Ranges of text which should be removed from the output
     */
    removals: Range[];
    /**
     * Resolved compiler options
     */
    compilerOptions: CompilerOptions;
    /**
     * Resolved handbook options
     */
    handbookOptions: HandbookOptions;
    /**
     * Flags which were parsed from the code
     */
    flagNotations: ParsedFlagNotation[];
    /**
     * The virtual files which were created
     */
    virtualFiles: VirtualFile[];
    /**
     * Positions of queries in the code
     */
    positionQueries: number[];
    /**
     * Positions of completions in the code
     */
    positionCompletions: number[];
    /**
     * Positions of errors in the code
     */
    positionHighlights: [start: number, end: number, text?: string][];
}
interface ParsedFlagNotation {
    type: 'compilerOptions' | 'handbookOptions' | 'tag' | 'unknown';
    name: string;
    value: any;
    start: number;
    end: number;
}
interface VirtualFile {
    offset: number;
    filename: string;
    filepath: string;
    content: string;
    extension: string;
    supportLsp?: boolean;
}

type TS = typeof typescript;
interface CompilerOptionDeclaration {
    name: string;
    type: 'list' | 'boolean' | 'number' | 'string' | Map<string, any>;
    element?: CompilerOptionDeclaration;
}
/**
 * Options for the `twoslasher` function
 */
interface TwoslashOptions extends CreateTwoslashOptions, TwoslashExecuteOptions {
}
/**
 * Options for twoslash instance
 */
interface TwoslashExecuteOptions extends Partial<Pick<TwoslashReturnMeta, 'positionQueries' | 'positionCompletions' | 'positionHighlights'>> {
    /** Allows setting any of the handbook options from outside the function, useful if you don't want LSP identifiers */
    handbookOptions?: Partial<HandbookOptions>;
    /** Allows setting any of the compiler options from outside the function */
    compilerOptions?: CompilerOptions;
    /** A set of known `// @[tags]` tags to extract and not treat as a comment */
    customTags?: string[];
    /**
     * A custom hook to filter out hover info for certain identifiers
     */
    shouldGetHoverInfo?: (identifier: string, start: number, filename: string) => boolean;
    /**
     * A custom predicate to filter out nodes for further processing
     */
    filterNode?: (node: NodeWithoutPosition) => boolean;
}
interface CreateTwoslashOptions extends TwoslashExecuteOptions {
    /**
     *  Allows applying custom transformers to the emit result, only useful with the showEmit output
     */
    customTransformers?: CustomTransformers;
    /**
     *  An optional copy of the TypeScript import, if missing it will be require'd.
     */
    tsModule?: TS;
    /**
     * Absolute path to the directory to look up built-in TypeScript .d.ts files.
     */
    tsLibDirectory?: string;
    /**
     * An optional Map object which is passed into @typescript/vfs - if you are using twoslash on the
     * web then you'll need this to set up your lib *.d.ts files. If missing, it will use your fs.
     */
    fsMap?: Map<string, string>;
    /** The cwd for the folder which the virtual fs should be overlaid on top of when using local fs, opts to process.cwd() if not present */
    vfsRoot?: string;
    /**
     * Cache the ts envs based on compiler options, defaults to true
     */
    cache?: boolean | Map<string, VirtualTypeScriptEnvironment>;
}

type TwoslashFunction = (code: string, extension?: string, options?: TwoslashExecuteOptions) => TwoslashReturn;
interface TwoslashInstance {
    /**
     * Run Twoslash on a string of code, with a particular extension
     */
    (code: string, extension?: string, options?: TwoslashExecuteOptions): TwoslashReturn;
    /**
     * Get the internal cache map
     */
    getCacheMap(): Map<string, VirtualTypeScriptEnvironment> | undefined;
}

declare class TwoslashError extends Error {
    title: string;
    description: string;
    recommendation: string;
    code: string | undefined;
    constructor(title: string, description: string, recommendation: string, code?: string | undefined);
}

declare const defaultCompilerOptions: CompilerOptions;
declare const defaultHandbookOptions: HandbookOptions;

declare function getObjectHash(obj: any): string;
/**
 * Creates a converter between index and position in a code block.
 */
declare function createPositionConverter(code: string): {
    lines: string[];
    indexToPos: (index: number) => Position;
    posToIndex: (line: number, character: number) => number;
};
/**
 * Remove ranages for a string, and update nodes' `start` property accordingly
 *
 * Note that items in `nodes` will be mutated
 */
declare function removeCodeRanges<T extends NodeStartLength>(code: string, removals: Range[], nodes: T[]): {
    code: string;
    removals: Range[];
    nodes: T[];
};
declare function removeCodeRanges(code: string, removals: Range[]): {
    code: string;
    removals: Range[];
    nodes: undefined;
};
/**
 * - Calculate nodes `line` and `character` properties to match the code
 * - Remove nodes that has negative `start` property
 * - Sort nodes by `start`
 *
 * Note that the nodes items will be mutated, clone them beforehand if not desired
 */
declare function resolveNodePositions(nodes: NodeWithoutPosition[], code: string): TwoslashNode[];
declare function resolveNodePositions(nodes: NodeWithoutPosition[], indexToPos: (index: number) => Position): TwoslashNode[];
declare function findFlagNotations(code: string, customTags: string[], tsOptionDeclarations: CompilerOptionDeclaration[]): ParsedFlagNotation[];
declare function findCutNotations(code: string): Range[];
declare function findQueryMarkers(code: string, meta: Pick<TwoslashReturnMeta, 'positionQueries' | 'positionCompletions' | 'positionHighlights' | 'removals'>, pc: ReturnType<typeof createPositionConverter>): Pick<TwoslashReturnMeta, "positionQueries" | "positionCompletions" | "positionHighlights" | "removals">;

/** To ensure that errors are matched up right */
declare function validateCodeForErrors(relevantErrors: NodeErrorWithoutPosition[], handbookOptions: {
    errors: number[];
}, vfsRoot: string): void;

export { type ParsedFlagNotation as A, defaultCompilerOptions as B, type CompilerOptionDeclaration as C, defaultHandbookOptions as D, type HandbookOptions as H, type NodeStartLength as N, type Position as P, type Range as R, type TwoslashExecuteOptions as T, type VirtualFile as V, type TwoslashReturn as a, type TwoslashOptions as b, type TwoslashInstance as c, createPositionConverter as d, findFlagNotations as e, findCutNotations as f, findQueryMarkers as g, resolveNodePositions as h, getObjectHash as i, TwoslashError as j, type TwoslashFunction as k, type NodeBase as l, type NodeHover as m, type NodeHighlight as n, type NodeQuery as o, type NodeCompletion as p, type NodeError as q, removeCodeRanges as r, type NodeTag as s, type TwoslashNode as t, type NodeWithoutPosition as u, validateCodeForErrors as v, type NodeErrorWithoutPosition as w, type TS as x, type CreateTwoslashOptions as y, type TwoslashReturnMeta as z };

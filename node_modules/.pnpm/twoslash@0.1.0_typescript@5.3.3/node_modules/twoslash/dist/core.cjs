'use strict';

const vfs = require('@typescript/vfs');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class TwoslashError extends Error {
  constructor(title, description, recommendation, code) {
    let message = `
## ${title}

${description}
`;
    if (recommendation)
      message += `
${recommendation}`;
    if (code)
      message += `
${code}`;
    super(message);
    __publicField(this, "title");
    __publicField(this, "description");
    __publicField(this, "recommendation");
    __publicField(this, "code");
    this.title = title;
    this.description = description;
    this.recommendation = recommendation;
    this.code = code;
  }
}

const defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
function objectHash(object, options) {
  if (options) {
    options = { ...defaults, ...options };
  } else {
    options = defaults;
  }
  const hasher = createHasher(options);
  hasher.dispatch(object);
  return hasher.toString();
}
const defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
function createHasher(options) {
  let buff = "";
  let context = /* @__PURE__ */ new Map();
  const write = (str) => {
    buff += str;
  };
  return {
    toString() {
      return buff;
    },
    getContext() {
      return context;
    },
    dispatch(value) {
      if (options.replacer) {
        value = options.replacer(value);
      }
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    },
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      if (objectLength < 10) {
        objType = "unknown:[" + objString + "]";
      } else {
        objType = objString.slice(8, objectLength - 1);
      }
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = context.get(object)) === void 0) {
        context.set(object, context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write("buffer:");
        return write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else if (!options.ignoreUnknown) {
          this.unkown(object, objType);
        }
      } else {
        let keys = Object.keys(object);
        if (options.unorderedObjects) {
          keys = keys.sort();
        }
        let extraKeys = [];
        if (options.respectType !== false && !isNativeFunction(object)) {
          extraKeys = defaultPrototypesKeys;
        }
        if (options.excludeKeys) {
          keys = keys.filter((key) => {
            return !options.excludeKeys(key);
          });
          extraKeys = extraKeys.filter((key) => {
            return !options.excludeKeys(key);
          });
        }
        write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          write(":");
          if (!options.excludeValues) {
            this.dispatch(object[key]);
          }
          write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    },
    array(arr, unordered) {
      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;
      write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = createHasher(options);
        hasher.dispatch(entry);
        for (const [key, value] of hasher.getContext()) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    },
    date(date) {
      return write("date:" + date.toJSON());
    },
    symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    unkown(value, type) {
      write(type);
      if (!value) {
        return;
      }
      write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          Array.from(value.entries()),
          true
          /* ordered */
        );
      }
    },
    error(err) {
      return write("error:" + err.toString());
    },
    boolean(bool) {
      return write("bool:" + bool);
    },
    string(string) {
      write("string:" + string.length + ":");
      write(string);
    },
    function(fn) {
      write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
      if (options.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn.name));
      }
      if (options.respectFunctionProperties) {
        this.object(fn);
      }
    },
    number(number) {
      return write("number:" + number);
    },
    xml(xml) {
      return write("xml:" + xml.toString());
    },
    null() {
      return write("Null");
    },
    undefined() {
      return write("Undefined");
    },
    regexp(regex) {
      return write("regex:" + regex.toString());
    },
    uint8array(arr) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint8clampedarray(arr) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int8array(arr) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint16array(arr) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int16array(arr) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint32array(arr) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int32array(arr) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float32array(arr) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float64array(arr) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    arraybuffer(arr) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    },
    url(url) {
      return write("url:" + url.toString());
    },
    map(map) {
      write("map:");
      const arr = [...map];
      return this.array(arr, options.unorderedSets !== false);
    },
    set(set) {
      write("set:");
      const arr = [...set];
      return this.array(arr, options.unorderedSets !== false);
    },
    file(file) {
      write("file:");
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    blob() {
      if (options.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error(
        'Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n'
      );
    },
    domwindow() {
      return write("domwindow");
    },
    bigint(number) {
      return write("bigint:" + number.toString());
    },
    /* Node.js standard native objects */
    process() {
      return write("process");
    },
    timer() {
      return write("timer");
    },
    pipe() {
      return write("pipe");
    },
    tcp() {
      return write("tcp");
    },
    udp() {
      return write("udp");
    },
    tty() {
      return write("tty");
    },
    statwatcher() {
      return write("statwatcher");
    },
    securecontext() {
      return write("securecontext");
    },
    connection() {
      return write("connection");
    },
    zlib() {
      return write("zlib");
    },
    context() {
      return write("context");
    },
    nodescript() {
      return write("nodescript");
    },
    httpparser() {
      return write("httpparser");
    },
    dataview() {
      return write("dataview");
    },
    signal() {
      return write("signal");
    },
    fsevent() {
      return write("fsevent");
    },
    tlswrap() {
      return write("tlswrap");
    }
  };
}
const nativeFunc = "[native code] }";
const nativeFuncLength = nativeFunc.length;
function isNativeFunction(f) {
  if (typeof f !== "function") {
    return false;
  }
  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;
}

const defaultCompilerOptions = {
  strict: true,
  module: 99,
  target: 99,
  allowJs: true,
  skipDefaultLibCheck: true,
  skipLibCheck: true
};
const defaultHandbookOptions = {
  errors: [],
  noErrors: false,
  noErrorsCutted: false,
  noErrorValidation: false,
  noStaticSemanticInfo: false,
  showEmit: false,
  showEmittedFile: void 0,
  keepNotations: false
};

const reConfigBoolean = /^\/\/\s?@(\w+)$/mg;
const reConfigValue = /^\/\/\s?@(\w+):\s?(.+)$/mg;
const reAnnonateMarkers = /^\s*\/\/\s*\^(\?|\||\^+)( .*)?$/mg;
const reCutBefore = /^\/\/\s?---cut(-before)?---$/mg;
const reCutAfter = /^\/\/\s?---cut-after---$/mg;
const reCutStart = /^\/\/\s?---cut-start---$/mg;
const reCutEnd = /^\/\/\s?---cut-end---$/mg;

function getObjectHash(obj) {
  return objectHash(obj);
}
function parsePrimitive(value, type) {
  if (typeof value === type)
    return value;
  switch (type) {
    case "number":
      return +value;
    case "string":
      return value;
    case "boolean":
      return value.toLowerCase() === "true" || value.length === 0;
  }
  throw new TwoslashError(
    `Unknown primitive value in compiler flag`,
    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,
    `This is likely a typo.`
  );
}
function typesToExtension(types) {
  const map = {
    js: "js",
    javascript: "js",
    ts: "ts",
    typescript: "ts",
    tsx: "tsx",
    jsx: "jsx",
    json: "json",
    jsn: "json",
    map: "json",
    mts: "ts",
    cts: "ts",
    mjs: "js",
    cjs: "js"
  };
  if (map[types])
    return map[types];
  throw new TwoslashError(
    `Unknown TypeScript extension given to Twoslash`,
    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,
    ``
  );
}
function getIdentifierTextSpans(ts, sourceFile, fileOffset) {
  const textSpans = [];
  checkChildren(sourceFile);
  return textSpans;
  function checkChildren(node) {
    ts.forEachChild(node, (child) => {
      if (ts.isIdentifier(child)) {
        const text = child.getText(sourceFile);
        const start = child.getStart(sourceFile, false) + fileOffset;
        const end = start + text.length;
        textSpans.push([start, end, text]);
      }
      checkChildren(child);
    });
  }
}
function isInRange(index, range) {
  return range[0] <= index && index <= range[1];
}
function isInRanges(index, ranges) {
  return ranges.find((range) => isInRange(index, range));
}
function mergeRanges(ranges) {
  ranges.sort((a, b) => a[0] - b[0]);
  const merged = [];
  for (const range of ranges) {
    const last = merged[merged.length - 1];
    if (last && last[1] >= range[0])
      last[1] = Math.max(last[1], range[1]);
    else
      merged.push(range);
  }
  return merged;
}
function getOptionValueFromMap(name, key, optMap) {
  const result = optMap.get(key.toLowerCase());
  if (result === void 0) {
    const keys = Array.from(optMap.keys());
    throw new TwoslashError(
      `Invalid inline compiler value`,
      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,
      `Allowed values: ${keys.join(",")}`
    );
  }
  return result;
}
function createPositionConverter(code) {
  const lines = Array.from(code.matchAll(/.*?($|\n)/g)).map((match) => match[0]);
  function indexToPos(index) {
    let character = index;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index = 0;
    for (let i = 0; i < line; i++)
      index += lines[i].length;
    index += character;
    return index;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
const reFilenamesMakers = /^\/\/\s?@filename: (.+)$/mg;
function splitFiles(code, defaultFileName, root) {
  const matches = Array.from(code.matchAll(reFilenamesMakers));
  const allFilenames = matches.map((match) => match[1].trimEnd());
  let currentFileName = allFilenames.includes(defaultFileName) ? "__index__.ts" : defaultFileName;
  const files = [];
  let index = 0;
  for (const match of matches) {
    const offset = match.index;
    const content = code.slice(index, offset);
    if (content) {
      files.push({
        offset: index,
        filename: currentFileName,
        filepath: root + currentFileName,
        content,
        extension: getExtension(currentFileName)
      });
    }
    currentFileName = match[1].trimEnd();
    index = offset;
  }
  if (index < code.length) {
    const content = code.slice(index);
    files.push({
      offset: index,
      filename: currentFileName,
      filepath: root + currentFileName,
      content,
      extension: getExtension(currentFileName)
    });
  }
  return files;
}
function getExtension(fileName) {
  return fileName.split(".").pop();
}
function removeCodeRanges(code, removals, nodes) {
  const ranges = mergeRanges(removals).sort((a, b) => b[0] - a[0]);
  let outputCode = code;
  for (const remove of ranges) {
    const removalLength = remove[1] - remove[0];
    outputCode = outputCode.slice(0, remove[0]) + outputCode.slice(remove[1]);
    nodes?.forEach((node) => {
      if (node.start + node.length <= remove[0])
        return void 0;
      else if (node.start < remove[1])
        node.start = -1;
      else
        node.start -= removalLength;
    });
  }
  return {
    code: outputCode,
    removals: ranges,
    nodes
  };
}
function resolveNodePositions(nodes, options) {
  const indexToPos = typeof options === "string" ? createPositionConverter(options).indexToPos : options;
  const resolved = nodes.filter((node) => node.start >= 0).sort((a, b) => a.start - b.start || a.type.localeCompare(b.type));
  resolved.forEach((node) => Object.assign(node, indexToPos(node.start)));
  return resolved;
}
function parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {
  if (customTags.includes(name)) {
    return {
      type: "tag",
      name,
      value,
      start,
      end
    };
  }
  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());
  if (compilerDecl) {
    switch (compilerDecl.type) {
      case "number":
      case "string":
      case "boolean":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: parsePrimitive(value, compilerDecl.type),
          start,
          end
        };
      case "list": {
        const elementType = compilerDecl.element.type;
        const strings = value.split(",");
        const resolved = typeof elementType === "string" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: resolved,
          start,
          end
        };
      }
      default: {
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),
          start,
          end
        };
      }
    }
  }
  if (Object.keys(defaultHandbookOptions).includes(name)) {
    if (name === "errors" && typeof value === "string")
      value = value.split(" ").map(Number);
    if (name === "noErrors" && typeof value === "string") {
      if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      else
        value = value.split(" ").map(Number);
    }
    return {
      type: "handbookOptions",
      name,
      value,
      start,
      end
    };
  }
  return {
    type: "unknown",
    name,
    value,
    start,
    end
  };
}
function findFlagNotations(code, customTags, tsOptionDeclarations) {
  const flagNotations = [];
  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {
    const index = match.index;
    const name = match[1];
    flagNotations.push(
      parseFlag(name, true, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  Array.from(code.matchAll(reConfigValue)).forEach((match) => {
    const name = match[1];
    if (name === "filename")
      return;
    const index = match.index;
    const value = match[2];
    flagNotations.push(
      parseFlag(name, value, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  return flagNotations;
}
function findCutNotations(code) {
  const removals = [];
  const cutBefore = [...code.matchAll(reCutBefore)];
  const cutAfter = [...code.matchAll(reCutAfter)];
  const cutStart = [...code.matchAll(reCutStart)];
  const cutEnd = [...code.matchAll(reCutEnd)];
  if (cutBefore.length) {
    const last = cutBefore[cutBefore.length - 1];
    removals.push([0, last.index + last[0].length + 1]);
  }
  if (cutAfter.length) {
    const first = cutAfter[0];
    removals.push([first.index, code.length]);
  }
  if (cutStart.length !== cutEnd.length) {
    throw new TwoslashError(
      `Mismatched cut markers`,
      `You have ${cutStart.length} cut-starts and ${cutEnd.length} cut-ends`,
      `Make sure you have a matching pair for each.`
    );
  }
  for (let i = 0; i < cutStart.length; i++) {
    const start = cutStart[i];
    const end = cutEnd[i];
    if (start.index > end.index) {
      throw new TwoslashError(
        `Mismatched cut markers`,
        `You have a cut-start at ${start.index} which is after the cut-end at ${end.index}`,
        `Make sure you have a matching pair for each.`
      );
    }
    removals.push([start.index, end.index + end[0].length + 1]);
  }
  return removals;
}
function findQueryMarkers(code, meta, pc) {
  if (code.includes("//")) {
    const linesQuery = /* @__PURE__ */ new Set();
    Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {
      const type = match[1];
      const index = match.index;
      meta.removals.push([index, index + match[0].length + 1]);
      const markerIndex = match[0].indexOf("^");
      const pos = pc.indexToPos(index + markerIndex);
      let targetLine = pos.line - 1;
      while (linesQuery.has(targetLine) && targetLine >= 0)
        targetLine -= 1;
      const targetIndex = pc.posToIndex(targetLine, pos.character);
      if (type === "?") {
        meta.positionQueries.push(targetIndex);
      } else if (type === "|") {
        meta.positionCompletions.push(targetIndex);
      } else {
        const markerLength = match[0].lastIndexOf("^") - markerIndex + 1;
        meta.positionHighlights.push([
          targetIndex,
          targetIndex + markerLength,
          match[2]?.trim()
        ]);
      }
      linesQuery.add(pos.line);
    });
  }
  return meta;
}
function removeTsExtension(filename) {
  const sansMapOrDTS = filename.replace(/\.map$/, "").replace(/\.d\.ts$/, ".ts").replace(/\.map$/, "");
  return sansMapOrDTS.replace(/\.[^/.]+$/, "");
}

function validateCodeForErrors(relevantErrors, handbookOptions, vfsRoot) {
  const unspecifiedErrors = relevantErrors.filter((e) => !handbookOptions.errors.includes(e.code));
  const errorsFound = Array.from(new Set(unspecifiedErrors.map((e) => e.code))).join(" ");
  if (unspecifiedErrors.length) {
    const errorsToShow = new Set(relevantErrors.map((e) => e.code));
    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(" ")}`;
    const missing = handbookOptions.errors.length ? `
The existing annotation specified ${handbookOptions.errors.join(" ")}` : `
Expected: ${codeToAdd}`;
    const filesToErrors = {};
    const noFiles = [];
    unspecifiedErrors.forEach((d) => {
      const fileRef = d.filename?.replace(vfsRoot, "");
      if (!fileRef) {
        noFiles.push(d);
      } else {
        const existing = filesToErrors[fileRef];
        if (existing)
          existing.push(d);
        else
          filesToErrors[fileRef] = [d];
      }
    });
    const showDiagnostics = (title, diags) => {
      return `${title}
  ${diags.map((e) => `[${e.code}] ${e.start} - ${e.text}`).join("\n  ")}`;
    };
    const innerDiags = [];
    if (noFiles.length)
      innerDiags.push(showDiagnostics("Ambient Errors", noFiles));
    Object.keys(filesToErrors).forEach((filepath) => {
      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]));
    });
    const allMessages = innerDiags.join("\n\n");
    const newErr = new TwoslashError(
      `Errors were thrown in the sample, but not included in an error tag`,
      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,
      `Compiler Errors:

${allMessages}`
    );
    throw newErr;
  }
}

function createTwoslasher(createOptions = {}) {
  const ts = createOptions.tsModule;
  const tsOptionDeclarations = ts.optionDeclarations;
  const useFS = !!createOptions.fsMap;
  const _root = createOptions.vfsRoot.replace(/\\/g, "/");
  const vfs$1 = createOptions.fsMap || /* @__PURE__ */ new Map();
  const system = useFS ? vfs.createSystem(vfs$1) : {
    ...vfs.createFSBackedSystem(vfs$1, _root, ts, createOptions.tsLibDirectory),
    // To work with non-hoisted packages structure
    realpath(path) {
      if (vfs$1.has(path))
        return path;
      return ts.sys.realpath?.(path) || path;
    }
  };
  const fsRoot = useFS ? "/" : `${_root}/`;
  const cache = createOptions.cache === false ? void 0 : createOptions.cache instanceof Map ? createOptions.cache : /* @__PURE__ */ new Map();
  function getEnv(compilerOptions) {
    if (!cache)
      return vfs.createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, createOptions.customTransformers);
    const key = getObjectHash(compilerOptions);
    if (!cache?.has(key)) {
      const env = vfs.createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, createOptions.customTransformers);
      cache?.set(key, env);
      return env;
    }
    return cache.get(key);
  }
  function twoslasher2(code, extension = "ts", options = {}) {
    const meta = {
      extension: typesToExtension(extension),
      compilerOptions: {
        ...defaultCompilerOptions,
        ...createOptions.compilerOptions,
        ...options.compilerOptions
      },
      handbookOptions: {
        ...defaultHandbookOptions,
        ...createOptions.handbookOptions,
        ...options.handbookOptions
      },
      removals: [],
      flagNotations: [],
      virtualFiles: [],
      positionQueries: options.positionQueries || [],
      positionCompletions: options.positionCompletions || [],
      positionHighlights: options.positionHighlights || []
    };
    const {
      customTags = createOptions.customTags || [],
      shouldGetHoverInfo = createOptions.shouldGetHoverInfo || (() => true),
      filterNode = createOptions.filterNode
    } = options;
    const defaultFilename = `index.${meta.extension}`;
    let nodes = [];
    const isInRemoval = (index) => index >= code.length || index < 0 || isInRanges(index, meta.removals);
    meta.flagNotations = findFlagNotations(code, customTags, tsOptionDeclarations);
    for (const flag of meta.flagNotations) {
      switch (flag.type) {
        case "unknown":
          continue;
        case "compilerOptions":
          meta.compilerOptions[flag.name] = flag.value;
          break;
        case "handbookOptions":
          meta.handbookOptions[flag.name] = flag.value;
          break;
        case "tag":
          nodes.push({
            type: "tag",
            name: flag.name,
            start: flag.end,
            length: 0,
            text: flag.value
          });
          break;
      }
      meta.removals.push([flag.start, flag.end]);
    }
    if (!meta.handbookOptions.noErrorValidation) {
      const unknownFlags = meta.flagNotations.filter((i) => i.type === "unknown");
      if (unknownFlags.length) {
        throw new TwoslashError(
          `Unknown inline compiler flags`,
          `The following flags are either valid TSConfig nor handbook options:
${unknownFlags.map((i) => `@${i.name}`).join(", ")}`,
          `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`
        );
      }
    }
    const env = getEnv(meta.compilerOptions);
    const ls = env.languageService;
    const pc = createPositionConverter(code);
    meta.removals.push(...findCutNotations(code));
    findQueryMarkers(code, meta, pc);
    const supportedFileTyes = ["js", "jsx", "ts", "tsx"];
    meta.virtualFiles = splitFiles(code, defaultFilename, fsRoot);
    const identifiersMap = /* @__PURE__ */ new Map();
    function getIdentifiersOfFile(file) {
      if (!identifiersMap.has(file.filename)) {
        const source = env.getSourceFile(file.filepath);
        identifiersMap.set(file.filename, getIdentifierTextSpans(ts, source, file.offset));
      }
      return identifiersMap.get(file.filename);
    }
    function getFileAtPosition(pos) {
      return meta.virtualFiles.find((i) => isInRange(pos, [i.offset, i.offset + i.content.length]));
    }
    function getQuickInfo(file, start, target) {
      const quickInfo = ls.getQuickInfoAtPosition(file.filepath, start - file.offset);
      if (quickInfo && quickInfo.displayParts) {
        const text = quickInfo.displayParts.map((dp) => dp.text).join("");
        const docs = quickInfo.documentation?.map((d) => d.text).join("\n") || void 0;
        const tags = quickInfo.tags?.map((t) => [t.name, t.text?.map((i) => i.text).join("")]);
        return {
          type: "hover",
          text,
          docs,
          tags,
          start,
          length: target.length,
          target
        };
      }
    }
    for (const file of meta.virtualFiles) {
      if (supportedFileTyes.includes(file.extension) || file.extension === "json" && meta.compilerOptions.resolveJsonModule) {
        file.supportLsp = true;
        env.createFile(file.filepath, file.content);
        getIdentifiersOfFile(file);
      }
    }
    if (!meta.handbookOptions.showEmit) {
      for (const file of meta.virtualFiles) {
        if (!file.supportLsp)
          continue;
        if (!meta.handbookOptions.noStaticSemanticInfo) {
          const identifiers = getIdentifiersOfFile(file);
          for (const [start, _end, target] of identifiers) {
            if (isInRemoval(start))
              continue;
            if (!shouldGetHoverInfo(target, start, file.filename))
              continue;
            const node = getQuickInfo(file, start, target);
            if (node)
              nodes.push(node);
          }
        }
      }
      for (const query of meta.positionQueries) {
        if (isInRemoval(query)) {
          throw new TwoslashError(
            `Invalid quick info query`,
            `The request on line ${pc.indexToPos(query).line + 2} for quickinfo via ^? is in a removal range.`,
            `This is likely that the positioning is off.`
          );
        }
        const file = getFileAtPosition(query);
        const identifiers = getIdentifiersOfFile(file);
        const id = identifiers.find((i) => isInRange(query, i));
        let node;
        if (id)
          node = getQuickInfo(file, id[0], id[2]);
        if (node) {
          node.type = "query";
          nodes.push(node);
        } else {
          const pos = pc.indexToPos(query);
          throw new TwoslashError(
            `Invalid quick info query`,
            `The request on line ${pos.line + 2} in ${file.filename} for quickinfo via ^? returned nothing from the compiler.`,
            `This is likely that the positioning is off.`
          );
        }
      }
      for (const highlight of meta.positionHighlights) {
        nodes.push({
          type: "highlight",
          start: highlight[0],
          length: highlight[1] - highlight[0],
          text: highlight[2]
        });
      }
      for (const target of meta.positionCompletions) {
        const file = getFileAtPosition(target);
        if (isInRemoval(target) || !file) {
          throw new TwoslashError(
            `Invalid completion query`,
            `The request on line ${pc.indexToPos(target).line + 2} for completions via ^| is in a removal range.`,
            `This is likely that the positioning is off.`
          );
        }
        let prefix = code.slice(0, target).match(/[$_\w]+$/)?.[0] || "";
        prefix = prefix.split(".").pop();
        let completions = [];
        if (prefix) {
          const result = ls.getCompletionsAtPosition(file.filepath, target - file.offset - 1, {
            triggerKind: 1,
            includeCompletionsForModuleExports: false
          });
          completions = (result?.entries ?? []).filter((i) => i.name.startsWith(prefix)) || [];
        } else {
          prefix = code[target - 1];
          if (prefix) {
            const result = ls.getCompletionsAtPosition(file.filepath, target - file.offset, {
              triggerKind: 2,
              triggerCharacter: prefix,
              includeCompletionsForModuleExports: false
            });
            completions = result?.entries ?? [];
          }
        }
        if (!completions?.length && !meta.handbookOptions.noErrorValidation) {
          const pos = pc.indexToPos(target);
          throw new TwoslashError(
            `Invalid completion query`,
            `The request on line ${pos.line} in ${file.filename} for completions via ^| returned no completions from the compiler.`,
            `This is likely that the positioning is off.`
          );
        }
        nodes.push({
          type: "completion",
          start: target,
          length: 0,
          completions,
          completionsPrefix: prefix
        });
      }
    }
    let errorNodes = [];
    for (const file of meta.virtualFiles) {
      if (!file.supportLsp)
        continue;
      if (meta.handbookOptions.noErrors !== true) {
        env.updateFile(file.filepath, file.content);
        const diagnostics = [
          ...ls.getSemanticDiagnostics(file.filepath),
          ...ls.getSyntacticDiagnostics(file.filepath)
        ];
        const ignores = Array.isArray(meta.handbookOptions.noErrors) ? meta.handbookOptions.noErrors : [];
        for (const diagnostic of diagnostics) {
          if (diagnostic.file?.fileName !== file.filepath)
            continue;
          if (ignores.includes(diagnostic.code))
            continue;
          const start = diagnostic.start + file.offset;
          if (meta.handbookOptions.noErrorsCutted && isInRemoval(start))
            continue;
          errorNodes.push({
            type: "error",
            start,
            length: diagnostic.length,
            code: diagnostic.code,
            filename: file.filename,
            id: `err-${diagnostic.code}-${start}-${diagnostic.length}`,
            text: ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n"),
            level: diagnostic.category
          });
        }
      }
    }
    if (filterNode) {
      nodes = nodes.filter(filterNode);
      errorNodes = errorNodes.filter(filterNode);
    }
    nodes.push(...errorNodes);
    if (!meta.handbookOptions.noErrorValidation && errorNodes.length)
      validateCodeForErrors(errorNodes, meta.handbookOptions, fsRoot);
    let outputCode = code;
    if (meta.handbookOptions.showEmit) {
      if (meta.handbookOptions.keepNotations) {
        throw new TwoslashError(
          `Option 'showEmit' cannot be used with 'keepNotations'`,
          "With `showEmit` enabled, the output will always be the emitted code",
          "Remove either option to continue"
        );
      }
      if (!meta.handbookOptions.keepNotations) {
        const { code: removedCode } = removeCodeRanges(outputCode, meta.removals);
        const files = splitFiles(removedCode, defaultFilename, fsRoot);
        for (const file of files)
          env.updateFile(file.filepath, file.content);
      }
      const emitFilename = meta.handbookOptions.showEmittedFile ? meta.handbookOptions.showEmittedFile : meta.compilerOptions.jsx === 1 ? "index.jsx" : "index.js";
      let emitSource = meta.virtualFiles.find((i) => removeTsExtension(i.filename) === removeTsExtension(emitFilename))?.filename;
      if (!emitSource && !meta.compilerOptions.outFile) {
        const allFiles = meta.virtualFiles.map((i) => i.filename).join(", ");
        throw new TwoslashError(
          `Could not find source file to show the emit for`,
          `Cannot find the corresponding **source** file: '${emitFilename}'`,
          `Looked for: ${emitSource} in the vfs - which contains: ${allFiles}`
        );
      }
      if (meta.compilerOptions.outFile)
        emitSource = meta.virtualFiles[0].filename;
      const output = ls.getEmitOutput(fsRoot + emitSource);
      const outfile = output.outputFiles.find((o) => o.name === fsRoot + emitFilename || o.name === emitFilename);
      if (!outfile) {
        const allFiles = output.outputFiles.map((o) => o.name).join(", ");
        throw new TwoslashError(
          `Cannot find the output file in the Twoslash VFS`,
          `Looking for ${emitFilename} in the Twoslash vfs after compiling`,
          `Looked for" ${fsRoot + emitFilename} in the vfs - which contains ${allFiles}.`
        );
      }
      outputCode = outfile.text;
      meta.extension = typesToExtension(getExtension(outfile.name));
      meta.removals.length = 0;
      nodes.length = 0;
    }
    if (!meta.handbookOptions.keepNotations) {
      const removed = removeCodeRanges(outputCode, meta.removals, nodes);
      outputCode = removed.code;
      nodes = removed.nodes;
      meta.removals = removed.removals;
    }
    const indexToPos = outputCode === code ? pc.indexToPos : createPositionConverter(outputCode).indexToPos;
    const resolvedNodes = resolveNodePositions(nodes, indexToPos);
    return {
      code: outputCode,
      nodes: resolvedNodes,
      meta,
      get queries() {
        return this.nodes.filter((i) => i.type === "query");
      },
      get completions() {
        return this.nodes.filter((i) => i.type === "completion");
      },
      get errors() {
        return this.nodes.filter((i) => i.type === "error");
      },
      get highlights() {
        return this.nodes.filter((i) => i.type === "highlight");
      },
      get hovers() {
        return this.nodes.filter((i) => i.type === "hover");
      },
      get tags() {
        return this.nodes.filter((i) => i.type === "tag");
      }
    };
  }
  twoslasher2.getCacheMap = () => {
    return cache;
  };
  return twoslasher2;
}
function twoslasher(code, lang, opts) {
  return createTwoslasher({
    ...opts,
    cache: false
  })(code, lang);
}

exports.TwoslashError = TwoslashError;
exports.createPositionConverter = createPositionConverter;
exports.createTwoslasher = createTwoslasher;
exports.defaultCompilerOptions = defaultCompilerOptions;
exports.defaultHandbookOptions = defaultHandbookOptions;
exports.findCutNotations = findCutNotations;
exports.findFlagNotations = findFlagNotations;
exports.findQueryMarkers = findQueryMarkers;
exports.getObjectHash = getObjectHash;
exports.removeCodeRanges = removeCodeRanges;
exports.resolveNodePositions = resolveNodePositions;
exports.twoslasher = twoslasher;
exports.validateCodeForErrors = validateCodeForErrors;

import { TwoslashReturn, twoslasher, TwoslashOptions, NodeError, NodeTag, NodeQuery, NodeCompletion, NodeHover, NodeHighlight, TwoslashExecuteOptions } from 'twoslash';
import { CodeToHastOptions, ShikijiTransformerContext, ShikijiTransformerContextCommon, ShikijiTransformer } from 'shikiji-core';
import { ElementContent, Element, Text } from 'hast';

declare module 'shikiji-core' {
    interface ShikijiTransformerContextMeta {
        twoslash?: TwoslashReturn;
    }
}
interface TransformerTwoslashOptions {
    /**
     * Languages to apply this transformer to
     */
    langs?: string[];
    /**
     * Requires `twoslash` to be presented in the code block meta to apply this transformer
     *
     * @default false
     */
    explicitTrigger?: boolean;
    /**
     * Mapping from language alias to language name
     */
    langAlias?: Record<string, string>;
    /**
     * Custom filter function to apply this transformer to
     * When specified, `langs` and `explicitTrigger` will be ignored
     */
    filter?: (lang: string, code: string, options: CodeToHastOptions) => boolean;
    /**
     * Custom instance of twoslasher function
     */
    twoslasher?: typeof twoslasher;
    /**
     * Options to pass to twoslash
     */
    twoslashOptions?: TwoslashOptions;
    /**
     * Custom renderers to decide how each info should be rendered
     */
    renderer?: TwoslashRenderer;
    /**
     * Strictly throw when there is an error
     * @default true
     */
    throws?: boolean;
}
interface TwoslashRenderer {
    lineError?(this: ShikijiTransformerContext, error: NodeError): ElementContent[];
    lineCustomTag?(this: ShikijiTransformerContext, tag: NodeTag): ElementContent[];
    lineQuery?(this: ShikijiTransformerContext, query: NodeQuery, targetNode?: Element | Text): ElementContent[];
    lineCompletion?(this: ShikijiTransformerContext, query: NodeCompletion): ElementContent[];
    nodeStaticInfo(this: ShikijiTransformerContext, info: NodeHover, node: Element | Text): Partial<ElementContent>;
    nodeError?(this: ShikijiTransformerContext, error: NodeError, node: Element | Text): Partial<ElementContent>;
    nodeQuery?(this: ShikijiTransformerContext, query: NodeQuery, node: Element | Text): Partial<ElementContent>;
    nodeCompletion?(this: ShikijiTransformerContext, query: NodeCompletion, node: Element | Text): Partial<ElementContent>;
    nodesHighlight?(this: ShikijiTransformerContext, highlight: NodeHighlight, nodes: ElementContent[]): ElementContent[];
}

type CompletionItem = NonNullable<NodeCompletion['completions']>[number];
declare const defaultCompletionIcons: Record<CompletionItem['kind'], Element | undefined>;
declare const defaultCustomTagIcons: Record<string, Element | undefined>;

interface RendererRichOptions {
    /**
     * Render JSDoc comments in hover popup.
     *
     * @default true
     */
    jsdoc?: boolean;
    /**
     * Custom icons for completion items.
     * A map from completion item kind to a HAST node.
     *
     * If `false`, no icons will be rendered.
     * @default defaultCompletionIcons
     */
    completionIcons?: Partial<Record<CompletionItem['kind'], ElementContent>> | false;
    /**
     * Custom icons for custom tags lines.
     * A map from tag name to a HAST node.
     *
     * If `false`, no icons will be rendered.
     * @default defaultCustomTagIcons
     */
    customTagIcons?: Partial<Record<string, ElementContent>> | false;
    /**
     * Custom formatter for the type info text.
     * Note that it might not be valid TypeScript syntax.
     *
     * @default defaultHoverInfoProcessor
     */
    processHoverInfo?: (info: string) => string;
    /**
     * Custom formatter for the docs text (can be markdown).
     *
     * @default undefined
     */
    processHoverDocs?: (docs: string) => string;
    /**
     * Classes added to injected elements
     */
    classExtra?: string;
    /**
     * Language for syntax highlight.
     * @default the language of the code block
     */
    lang?: string;
    /**
     * @deprecated Use `processHoverInfo` instead.
     */
    formatInfo?(info: string): string;
    /**
     * Custom function to render markdown.
     *
     * By default it pass-through the markdown.
     */
    renderMarkdown?(this: ShikijiTransformerContextCommon, markdown: string): ElementContent[];
    /**
     * Custom function to render inline markdown.
     *
     * By default it pass-through the markdown.
     */
    renderMarkdownInline?(this: ShikijiTransformerContextCommon, markdown: string): ElementContent[];
    /**
     * Extensions for the genreated HAST tree.
     */
    hast?: {
        /**
         * The <code> block for in the hover popup.
         */
        popupTypes?: HastExtension;
        /**
         * The documentation block in the hover popup. Can be markdown rendered if `renderMarkdown` is provided.
         */
        popupDocs?: HastExtension;
        /**
         * The container of jsdoc tags in the hover popup.
         */
        popupDocsTags?: HastExtension;
        /**
         * The token for the hover informaton.
         */
        hoverToken?: HastExtension;
        /**
         * The container of the hover popup.
         */
        hoverPopup?: HastExtension;
        /**
         * Custom function to compose the hover token.
         */
        hoverCompose?: (parts: {
            popup: Element;
            token: Text | Element;
        }) => ElementContent[];
        /**
         * The token for the query informaton.
         */
        queryToken?: HastExtension;
        /**
         * The container of the query popup.
         */
        queryPopup?: HastExtension;
        /**
         * Custom function to compose the hover token.
         */
        queryCompose?: (parts: {
            popup: Element;
            token: Text | Element;
        }) => ElementContent[];
        /**
         * The token for the completion informaton.
         */
        completionToken?: HastExtension;
        /**
         * The cursor element in the completion popup.
         */
        completionCursor?: HastExtension;
        /**
         * The container of the completion popup.
         */
        completionPopup?: HastExtension;
        /**
         * Custom function to compose the completion token.
         */
        completionCompose?: (parts: {
            popup: Element;
            cursor: Element;
        }) => ElementContent[];
        /**
         * The token for the error informaton.
         */
        errorToken?: HastExtension;
        /**
         * The wrapper for the highlighted nodes.
         */
        nodesHighlight?: HastExtension;
    };
}
interface HastExtension {
    tagName?: string;
    properties?: Element['properties'];
    class?: string;
    children?: (input: ElementContent[]) => ElementContent[];
}
/**
 * An alternative renderer that providers better prefixed class names,
 * with syntax highlight for the info text.
 */
declare function rendererRich(options?: RendererRichOptions): TwoslashRenderer;
/**
 * The default hover info processor, which will do some basic cleanup
 */
declare function defaultHoverInfoProcessor(type: string): string;

/**
 * The default renderer aligning with the original `shiki-twoslash` output.
 */
declare function rendererClassic(): TwoslashRenderer;

/**
 * This file is the core of the shikiji-twoslash package,
 * Decoupled from twoslash's implementation and allowing to introduce custom implementation or cache system.
 */

declare function defaultTwoslashOptions(): TwoslashExecuteOptions;
type TwoslashFunction = (code: string, lang?: string, options?: TwoslashExecuteOptions) => TwoslashReturn;
declare function createTransformerFactory(defaultTwoslasher: TwoslashFunction, defaultRenderer?: TwoslashRenderer): (options?: TransformerTwoslashOptions) => ShikijiTransformer;

export { type CompletionItem, type HastExtension, type RendererRichOptions, type TransformerTwoslashOptions, type TwoslashRenderer, createTransformerFactory, defaultCompletionIcons, defaultCustomTagIcons, defaultHoverInfoProcessor, defaultTwoslashOptions, rendererClassic, rendererRich };
